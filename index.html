<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3Dåœ°çƒä»ª - æ™ºèƒ½å®šä½</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
            touch-action: none; /* é˜²æ­¢é¡µé¢æ»šåŠ¨ */
        }

        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: calc(100vw - 20px);
            z-index: 1000;
        }

        @media (max-width: 768px) {
            #info {
                font-size: 10px;
                padding: 8px;
                top: 5px;
                left: 5px;
            }
        }

        #coordinates {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        @media (max-width: 768px) {
            #coordinates {
                font-size: 12px;
                padding: 8px;
                bottom: 5px;
                right: 5px;
            }
        }

        #compass {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
        }

        @media (max-width: 768px) {
            #compass {
                width: 60px;
                height: 60px;
                right: 5px;
            }
        }

        .compass-arrow {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 15px solid #ff4444;
            position: absolute;
            top: 8px;
        }

        @media (max-width: 768px) {
            .compass-arrow {
                border-left-width: 4px;
                border-right-width: 4px;
                border-bottom-width: 12px;
                top: 6px;
            }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            text-align: center;
            z-index: 2000;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .controls {
                bottom: 5px;
                left: 5px;
                gap: 5px;
            }
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 768px) {
            .control-btn {
                padding: 6px 10px;
                font-size: 10px;
                min-height: 32px;
            }
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .control-btn:active {
            transform: translateY(0px);
        }

        /* åœ°ç‚¹è¾“å…¥é¢æ¿ */
        #location-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            z-index: 3000;
            min-width: 280px;
        }

        @media (max-width: 768px) {
            #location-panel {
                padding: 15px;
                min-width: 250px;
                max-width: calc(100vw - 40px);
            }
        }

        /* åŸå¸‚é€‰æ‹©é¢æ¿ */
        #city-selector-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            z-index: 3000;
            min-width: 300px;
        }

        @media (max-width: 768px) {
            #city-selector-panel {
                padding: 15px;
                min-width: 280px;
                max-width: calc(100vw - 40px);
            }
        }

        .city-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        @media (max-width: 768px) {
            .city-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .city-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        @media (max-width: 768px) {
            .city-btn {
                padding: 5px 6px;
                font-size: 11px;
            }
        }

        .city-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        #location-panel h3 {
            margin: 0 0 15px 0;
            color: #00ffff;
            font-size: 18px;
            text-align: center;
        }

        @media (max-width: 768px) {
            #location-panel h3 {
                font-size: 16px;
                margin-bottom: 12px;
            }
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ffffff;
        }

        @media (max-width: 768px) {
            .input-group label {
                font-size: 12px;
            }
        }

        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .input-group input {
                padding: 6px;
                font-size: 12px;
            }
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .panel-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .panel-buttons {
                gap: 8px;
                margin-top: 12px;
            }
        }

        .panel-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        @media (max-width: 768px) {
            .panel-btn {
                padding: 8px;
                font-size: 12px;
            }
        }

        .panel-btn.primary {
            background: #00ffff;
            color: #000;
        }

        .panel-btn.secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .panel-btn:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }

        /* åœ°ç‚¹æ ‡è®°æ ·å¼ */
        .location-marker {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            border: 2px solid #ffffff;
            position: absolute;
            pointer-events: none;
            z-index: 500;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.8);
        }

        @media (max-width: 768px) {
            .location-marker {
                width: 6px;
                height: 6px;
                border-width: 1px;
            }
        }

        /* æ—¶é—´æ˜¾ç¤º */
        #time-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            z-index: 1000;
            min-width: 140px;
        }

        @media (max-width: 768px) {
            #time-display {
                font-size: 10px;
                padding: 8px;
                top: 5px;
                right: 5px;
            }
        }

        /* æ˜æš—é¢è¿‡æ¸¡ */
        .day-night-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        /* å¤©æ°”é¢„æŠ¥æ ·å¼ */
        #weather-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
            min-width: 200px;
            z-index: 1000;
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½åæ˜¾ç¤º */
        }

        @media (max-width: 768px) {
            #weather-display {
                left: 5px;
                top: 5px;
                padding: 10px;
                min-width: 180px;
                font-size: 11px;
            }
        }

        #weather-main {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        #weather-icon {
            font-size: 32px;
            margin-right: 10px;
        }

        @media (max-width: 768px) {
            #weather-icon {
                font-size: 28px;
                margin-right: 8px;
            }
        }

        #weather-temp {
            font-size: 24px;
            font-weight: bold;
            color: #00ffff;
        }

        @media (max-width: 768px) {
            #weather-temp {
                font-size: 20px;
            }
        }

        #weather-condition {
            font-size: 14px;
            margin-bottom: 4px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            #weather-condition {
                font-size: 12px;
            }
        }

        #weather-details {
            margin-bottom: 8px;
        }

        #weather-details div {
            margin-bottom: 2px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }

        #weather-forecast {
            display: flex;
            gap: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
        }

        .forecast-day {
            flex: 1;
            text-align: center;
        }

        .forecast-date {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 2px;
        }

        .forecast-icon {
            font-size: 16px;
            margin-bottom: 2px;
        }

        .forecast-temp {
            font-size: 11px;
            font-weight: bold;
            color: #00ffff;
        }

        @media (max-width: 768px) {
            #weather-forecast {
                gap: 5px;
            }

            .forecast-date {
                font-size: 9px;
            }

            .forecast-icon {
                font-size: 14px;
            }

            .forecast-temp {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨åŠ è½½åœ°çƒä»ª...</div>
    <div id="container"></div>

    <!-- æ—¶é—´æ˜¾ç¤º -->
    <div id="time-display">
        <div id="current-time">00:00:00</div>
        <div id="current-date">2025-01-01</div>
        <div id="location-name">æœªçŸ¥ä½ç½®</div>
        <div id="cloud-status">â˜ï¸ äº‘å›¾: åŠ è½½ä¸­...</div>
        <div id="weather-alert" style="color: #ffaa00; font-size: 10px; margin-top: 2px;"></div>
    </div>

    <!-- å¤©æ°”é¢„æŠ¥æ˜¾ç¤º -->
    <div id="weather-display">
        <div id="weather-main">
            <div id="weather-icon">ğŸŒ¤ï¸</div>
            <div id="weather-temp">--Â°C</div>
        </div>
        <div id="weather-details">
            <div id="weather-condition">åŠ è½½ä¸­...</div>
            <div id="weather-wind">é£é€Ÿ: --km/h</div>
        </div>
        <div id="weather-forecast">
            <div class="forecast-day" id="forecast-today">
                <div class="forecast-date">ä»Šå¤©</div>
                <div class="forecast-icon">ğŸŒ¤ï¸</div>
                <div class="forecast-temp">--Â°/--Â°</div>
            </div>
            <div class="forecast-day" id="forecast-tomorrow">
                <div class="forecast-date">æ˜å¤©</div>
                <div class="forecast-icon">ğŸŒ¤ï¸</div>
                <div class="forecast-temp">--Â°/--Â°</div>
            </div>
        </div>
    </div>


    <div id="coordinates">
        <div>å½“å‰ä½ç½®ç»åº¦: <span id="longitude">0.0Â°</span></div>
        <div>å½“å‰ä½ç½®çº¬åº¦: <span id="latitude">0.0Â°</span></div>
        <div>ç¼©æ”¾: <span id="zoom">1.0x</span></div>
    </div>

    <div id="compass">
        <div class="compass-arrow" id="compass-arrow"></div>
        <div style="font-size: 10px; color: #00ffff; position: absolute; bottom: 8px;">N</div>
    </div>

    <div class="controls">
        <button class="control-btn" onclick="resetView()">é‡ç½®è§†å›¾</button>
        <button class="control-btn" onclick="toggleAutoRotate()">è‡ªåŠ¨æ—‹è½¬</button>
        <button class="control-btn" onclick="showEquator()">æ˜¾ç¤ºèµ¤é“</button>
        <button class="control-btn" onclick="showLocationPanel()">ğŸ“ æ ‡è®°åœ°ç‚¹</button>
        <button class="control-btn" onclick="getCurrentLocation()">ğŸ“ è·å–ä½ç½®</button>
        <button class="control-btn" onclick="toggleClouds()">â˜ï¸ æ˜¾ç¤ºäº‘å±‚</button>
        <button class="control-btn" onclick="refreshClouds()">ğŸ”„ åˆ·æ–°äº‘å›¾</button>
        <button class="control-btn" onclick="showCitySelector()">ğŸŒ¤ï¸ å¤©æ°”é¢„æŠ¥</button>
    </div>

    <!-- åœ°ç‚¹è¾“å…¥é¢æ¿ -->
    <div id="location-panel">
        <h3>è¾“å…¥åœ°ç‚¹åæ ‡</h3>
        <div class="input-group">
            <label for="input-latitude">çº¬åº¦ (-90Â° åˆ° 90Â°):</label>
            <input type="number" id="input-latitude" placeholder="ä¾‹å¦‚: 39.9042" min="-90" max="90" step="0.0001">
        </div>
        <div class="input-group">
            <label for="input-longitude">ç»åº¦ (-180Â° åˆ° 180Â°):</label>
            <input type="number" id="input-longitude" placeholder="ä¾‹å¦‚: 116.4074" min="-180" max="180" step="0.0001">
        </div>
        <div class="input-group">
            <label for="input-location-name">åœ°ç‚¹åç§°:</label>
            <input type="text" id="input-location-name" placeholder="ä¾‹å¦‚: åŒ—äº¬">
        </div>
        <div class="panel-buttons">
            <button class="panel-btn secondary" onclick="hideLocationPanel()">å–æ¶ˆ</button>
            <button class="panel-btn primary" onclick="markLocation()">æ ‡è®°</button>
        </div>
    </div>

    <!-- åŸå¸‚é€‰æ‹©é¢æ¿ -->
    <div id="city-selector-panel">
        <h3>é€‰æ‹©åŸå¸‚è·å–å¤©æ°”</h3>
        <div class="input-group">
            <label for="city-search">åŸå¸‚åç§°:</label>
            <input type="text" id="city-search" placeholder="è¾“å…¥åŸå¸‚åç§°ï¼Œå¦‚ï¼šåŒ—äº¬ã€ä¸Šæµ·ã€Tokyo">
        </div>
        <div class="input-group">
            <label>çƒ­é—¨åŸå¸‚:</label>
            <div class="city-buttons">
                <button class="city-btn" onclick="selectCity('åŒ—äº¬')">åŒ—äº¬</button>
                <button class="city-btn" onclick="selectCity('ä¸Šæµ·')">ä¸Šæµ·</button>
                <button class="city-btn" onclick="selectCity('å¹¿å·')">å¹¿å·</button>
                <button class="city-btn" onclick="selectCity('æ·±åœ³')">æ·±åœ³</button>
                <button class="city-btn" onclick="selectCity('Tokyo')">ä¸œäº¬</button>
                <button class="city-btn" onclick="selectCity('New York')">çº½çº¦</button>
                <button class="city-btn" onclick="selectCity('London')">ä¼¦æ•¦</button>
                <button class="city-btn" onclick="selectCity('Sydney')">æ‚‰å°¼</button>
            </div>
        </div>
        <div class="panel-buttons">
            <button class="panel-btn secondary" onclick="hideCitySelector()">å–æ¶ˆ</button>
            <button class="panel-btn primary" onclick="searchWeatherByCity()">æœç´¢</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        /*
         * å¤©æ°”APIé…ç½®è¯´æ˜ï¼š
         *
         * å½“å‰ä½¿ç”¨Open-Meteoå…è´¹APIï¼ˆæ— éœ€API keyï¼‰ï¼Œæ”¯æŒå…¨çƒå¤©æ°”æ•°æ®ã€‚
         *
         * å¦‚æœéœ€è¦æ›´è¯¦ç»†çš„å¤©æ°”ä¿¡æ¯ï¼ˆå¦‚ç©ºæ°”è´¨é‡ç­‰ï¼‰ï¼Œå¯ä»¥é…ç½®WeatherAPI.com:
         * 1. è®¿é—® https://www.weatherapi.com/ æ³¨å†Œè´¦å·
         * 2. è·å–å…è´¹API keyï¼ˆæ¯æ—¥1000æ¬¡è°ƒç”¨ï¼‰
         * 3. å°†ä¸‹é¢çš„ WEATHER_API_KEY æ›¿æ¢ä¸ºæ‚¨çš„çœŸå®key
         * 4. å–æ¶ˆæ³¨é‡Š loadWeatherFromWeatherAPI å‡½æ•°çš„è°ƒç”¨
         *
         * const WEATHER_API_KEY = 'your_api_key_here';
         */

        let scene, camera, renderer, globe, controls;
        let isAutoRotating = false;
        let equatorLine;
        let loadingDiv = document.getElementById('loading');
        let locationMarkers = [];
        let currentLocation = null;
        let dayNightOverlay = null;
        let sunLight;
        let userLatitude = 0;
        let userLongitude = 0;
        let currentCity = 'åŒ—äº¬'; // é»˜è®¤åŸå¸‚
        let weatherData = null;
        let currentLocationLat = 39.9042; // åŒ—äº¬çº¬åº¦
        let currentLocationLon = 116.4074; // åŒ—äº¬ç»åº¦
        const STORAGE_KEYS = {
            CITY: 'earth_globe_selected_city',
            LOCATION: 'earth_globe_user_location',
            CAMERA_POSITION: 'earth_globe_camera_position',
            CAMERA_TARGET: 'earth_globe_camera_target'
        };
        let cloudsVisible = true; // äº‘å±‚æ˜¾ç¤ºçŠ¶æ€

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3;

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // åˆ›å»ºæ§åˆ¶å™¨ - æ”¯æŒè§¦æ‘¸è®¾å¤‡
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = false;
            controls.minDistance = 1.5;
            controls.maxDistance = 5;

            // è§¦æ‘¸è®¾å¤‡ä¼˜åŒ–
            if ('ontouchstart' in window) {
                controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                controls.enablePan = false; // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šç¦ç”¨å¹³ç§»
            }

            // åˆ›å»ºåœ°çƒ
            createGlobe();

            // æ·»åŠ å…‰æº
            addLights();

            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            addStars();

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);

            // åŒå‡»é‡ç½®è§†å›¾
            renderer.domElement.addEventListener('dblclick', resetView);

            // éšè—åŠ è½½æç¤º
            loadingDiv.style.display = 'none';

            // åˆå§‹åŒ–äº‘å±‚æ§åˆ¶æŒ‰é’®çŠ¶æ€
            updateCloudToggleButton();

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }

        // åˆ›å»ºåœ°çƒ
        function createGlobe() {
            // åˆ›å»ºåœ°çƒå‡ ä½•ä½“
            const geometry = new THREE.SphereGeometry(1, 64, 64);

            // åˆ›å»ºåœ°çƒæè´¨ (ä½¿ç”¨ç¨‹åºåŒ–çº¹ç†ä½œä¸ºåœ°çƒçº¹ç†)
            const material = createEarthMaterial();

            // åˆ›å»ºç½‘æ ¼
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // æ·»åŠ å¤§æ°”å±‚æ•ˆæœ
            addAtmosphere();

            // æ·»åŠ äº‘å±‚æ•ˆæœ
            addClouds();
        }

        // åˆ›å»ºåœ°çƒæè´¨
        function createEarthMaterial() {
            const textureLoader = new THREE.TextureLoader();

            // ä½¿ç”¨å¯é çš„åœ°çƒçº¹ç†èµ„æº
            const earthTexture = textureLoader.load(
                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
                // åŠ è½½å®Œæˆå›è°ƒ
                function(texture) {
                    console.log('åœ°çƒçº¹ç†åŠ è½½å®Œæˆ');
                },
                // åŠ è½½è¿›åº¦å›è°ƒ
                undefined,
                // åŠ è½½é”™è¯¯å›è°ƒ
                function(err) {
                    console.error('åœ°çƒçº¹ç†åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç¨‹åºåŒ–çº¹ç†');
                    createProceduralEarthTexture();
                }
            );

            // ä½¿ç”¨ç®€åŒ–çš„æ³•çº¿è´´å›¾æˆ–ä¸ä½¿ç”¨
            const normalTexture = textureLoader.load(
                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg',
                undefined,
                undefined,
                function(err) {
                    console.log('æ³•çº¿è´´å›¾åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€æè´¨');
                }
            );

            // é•œé¢è´´å›¾
            const specularTexture = textureLoader.load(
                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg',
                undefined,
                undefined,
                function(err) {
                    console.log('é•œé¢è´´å›¾åŠ è½½å¤±è´¥');
                }
            );

            // è®¾ç½®çº¹ç†å±æ€§
            earthTexture.wrapS = THREE.RepeatWrapping;
            earthTexture.wrapT = THREE.ClampToEdgeWrapping;
            if (normalTexture.image) {
                normalTexture.wrapS = THREE.RepeatWrapping;
                normalTexture.wrapT = THREE.ClampToEdgeWrapping;
            }
            if (specularTexture.image) {
                specularTexture.wrapS = THREE.RepeatWrapping;
                specularTexture.wrapT = THREE.ClampToEdgeWrapping;
            }

            // åˆ›å»ºæè´¨
            const material = new THREE.MeshPhongMaterial({
                map: earthTexture,
                normalMap: normalTexture,
                specularMap: specularTexture,
                shininess: 15,
                specular: 0x444444,
                transparent: false
            });

            return material;
        }

        // åˆ›å»ºç¨‹åºåŒ–åœ°çƒçº¹ç†ä½œä¸ºåå¤‡æ–¹æ¡ˆ
        function createProceduralEarthTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºåœ°çƒçš„åŸºç¡€é¢œè‰²æ¸å˜
            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, '#4A90E2');    // æµ·æ´‹è“è‰²
            gradient.addColorStop(0.3, '#2E8B57');  // æµ·ç»¿è‰²
            gradient.addColorStop(0.6, '#228B22');  // æ£®æ—ç»¿
            gradient.addColorStop(0.8, '#8B4513');  // è¤è‰²
            gradient.addColorStop(1, '#F5F5DC');    // ç±³è‰²

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 256);

            // æ·»åŠ ä¸€äº›éšæœºçš„é™†åœ°æ–‘å—
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 256;
                const size = Math.random() * 30 + 10;

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = Math.random() > 0.5 ? '#228B22' : '#8B4513';
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            if (globe && globe.material) {
                globe.material.map = texture;
                globe.material.needsUpdate = true;
            }
        }

        // æ·»åŠ å¤§æ°”å±‚æ•ˆæœ
        function addAtmosphere() {
            const atmosphereGeometry = new THREE.SphereGeometry(1.05, 64, 64);
            const atmosphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });

            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
        }

        // æ·»åŠ äº‘å±‚æ•ˆæœ
        function addClouds() {
            const cloudGeometry = new THREE.SphereGeometry(1.02, 64, 64);
            const cloudMaterial = new THREE.MeshLambertMaterial({
                transparent: true,
                opacity: 0.4
            });

            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);

            // æ ¹æ®å½“å‰çŠ¶æ€å†³å®šæ˜¯å¦æ·»åŠ åˆ°åœºæ™¯
            if (cloudsVisible) {
                scene.add(clouds);
            }

            // å­˜å‚¨äº‘å±‚å¯¹è±¡å¼•ç”¨
            window.cloudsMesh = clouds;

            // è®©äº‘å±‚ç¼“æ…¢æ—‹è½¬ï¼ˆä»…åœ¨å¯è§æ—¶ï¼‰
            function animateClouds() {
                if (clouds && cloudsVisible) {
                    clouds.rotation.y += 0.0005;
                }
                requestAnimationFrame(animateClouds);
            }
            animateClouds();

            // åŠ è½½å®æ—¶å«æ˜Ÿäº‘å›¾ï¼ˆæ— è®ºæ˜¯å¦å¯è§éƒ½ä¼šåŠ è½½ï¼‰
            loadSatelliteClouds();

            // è®¾ç½®äº‘å›¾è‡ªåŠ¨æ›´æ–° (æ¯30åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡)
            setInterval(loadSatelliteClouds, 30 * 60 * 1000);
        }

        // æ·»åŠ å…‰æº
        function addLights() {
            // ä¸»å…‰æº (å¤ªé˜³) - æ›´å¼ºçš„æ–¹å‘å…‰
            sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(10, 0, 0); // ä»ä¾§é¢ç…§å°„
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // å¼±ç¯å¢ƒå…‰æ¨¡æ‹Ÿåœ°çƒè‡ªå‘å…‰å’Œæ•£å°„å…‰ - å¢å¼ºä»¥å‡å°‘æš—é¢è¿‡æš—
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // åœ°çƒé˜´å½±ä¸€ä¾§çš„è¡¥å…‰ - å¢å¼º
            const rimLight = new THREE.DirectionalLight(0x87CEEB, 0.4);
            rimLight.position.set(-10, 0, 0); // ä»ç›¸åæ–¹å‘è¡¥å…‰
            scene.add(rimLight);

            // æ›´æ–°æ—¥å¤œå¾ªç¯
            updateDayNightCycle();
        }

        // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
        function addStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000; // æ˜Ÿæ˜Ÿæ•°é‡
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                // åˆ›å»ºçƒå½¢åˆ†å¸ƒçš„æ˜Ÿæ˜Ÿï¼Œè·ç¦»è¶³å¤Ÿè¿œ
                const radius = 300 + Math.random() * 400; // è·ç¦»300-700å•ä½
                const theta = Math.random() * Math.PI * 2; // æ°´å¹³è§’åº¦ 0-2Ï€
                const phi = Math.acos(2 * Math.random() - 1); // å‚ç›´è§’åº¦ 0-Ï€

                // çƒåæ ‡è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);     // x
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta); // y
                positions[i * 3 + 2] = radius * Math.cos(phi);                   // z
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.8, // ç¨å¾®è°ƒå¤§ä¸€ç‚¹
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // å‘å…‰æ•ˆæœ
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            // æ·»åŠ ç¼“æ…¢çš„æ—‹è½¬æ•ˆæœ
            function animateStars() {
                stars.rotation.y += 0.00005; // æ›´æ…¢çš„æ—‹è½¬
                requestAnimationFrame(animateStars);
            }
            animateStars();
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            controls.reset();
            camera.position.set(0, 0, 3);
            controls.update();
        }

        // åˆ‡æ¢è‡ªåŠ¨æ—‹è½¬
        function toggleAutoRotate() {
            isAutoRotating = !isAutoRotating;
            controls.autoRotate = isAutoRotating;
            controls.autoRotateSpeed = 0.5;
        }

        // æ˜¾ç¤º/éšè—èµ¤é“
        function showEquator() {
            if (equatorLine) {
                scene.remove(equatorLine);
                equatorLine = null;
            } else {
                const equatorGeometry = new THREE.TorusGeometry(1.01, 0.01, 8, 64);
                const equatorMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                });
                equatorLine = new THREE.Mesh(equatorGeometry, equatorMaterial);
                equatorLine.rotation.x = Math.PI / 2;
                scene.add(equatorLine);
            }
        }

        // æ›´æ–°æŒ‡ç¤ºå™¨
        function updateIndicators() {
            // æ˜¾ç¤ºå½“å‰é€‰æ‹©ä½ç½®çš„ç»çº¬åº¦ï¼ˆè€Œä¸æ˜¯ç›¸æœºè§†è§’ï¼‰
            document.getElementById('latitude').textContent = currentLocationLat.toFixed(4) + 'Â°';
            document.getElementById('longitude').textContent = currentLocationLon.toFixed(4) + 'Â°';

            // æ›´æ–°ç¼©æ”¾æŒ‡ç¤ºå™¨
            const zoom = camera.position.distanceTo(controls.target) / 3;
            document.getElementById('zoom').textContent = (1 / zoom).toFixed(1) + 'x';

            // æ›´æ–°æŒ‡å—é’ˆ (åŸºäºç›¸æœºè§†è§’)
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.normalize();
            const compassRotation = Math.atan2(direction.x, direction.z);
            document.getElementById('compass-arrow').style.transform = `rotate(${compassRotation}rad)`;
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            controls.update();
            updateIndicators();
            updateLocationLabels();

            // å®šæœŸä¿å­˜ç›¸æœºä½ç½®ï¼ˆæ¯30ç§’ä¿å­˜ä¸€æ¬¡ï¼Œé¿å…è¿‡äºé¢‘ç¹ï¼‰
            const now = Date.now();
            if (!window.lastSaveTime || now - window.lastSaveTime > 30000) {
                saveUserSettings();
                window.lastSaveTime = now;
            }

            renderer.render(scene, camera);
        }

        // åˆå§‹åŒ–
        init();

        // æ›´æ–°æ—¶é—´æ˜¾ç¤º
        function updateTimeDisplay() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const dateString = now.toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });

            document.getElementById('current-time').textContent = timeString;
            document.getElementById('current-date').textContent = dateString;

            // æ¯ç§’æ›´æ–°ä¸€æ¬¡
            setTimeout(updateTimeDisplay, 1000);
        }

        // è·å–å½“å‰ä½ç½®
        function getCurrentLocation() {
            if (!navigator.geolocation) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½åŠŸèƒ½');
                return;
            }

            loadingDiv.style.display = 'block';
            loadingDiv.textContent = 'æ­£åœ¨è·å–ä½ç½®...';

            navigator.geolocation.getCurrentPosition(
                function(position) {
                    userLatitude = position.coords.latitude;
                    userLongitude = position.coords.longitude;

                    // æ›´æ–°å½“å‰ä½ç½®åæ ‡
                    currentLocationLat = userLatitude;
                    currentLocationLon = userLongitude;

                    // è®¾ç½®å½“å‰ä½ç½®ä¸ºå½“å‰åŸå¸‚
                    currentCity = `ä½ç½®(${userLatitude.toFixed(2)}, ${userLongitude.toFixed(2)})`;

                    // ä¿å­˜è®¾ç½®
                    saveUserSettings();

                    // æ ‡è®°å½“å‰ä½ç½®
                    markLocationAt(userLatitude, userLongitude, 'ğŸ“ æˆ‘çš„ä½ç½®');

                    // ç§»åŠ¨ç›¸æœºåˆ°å½“å‰ä½ç½®
                    moveCameraToLocation(userLatitude, userLongitude);

                    // å…ˆè·å–ä½ç½®åç§°ï¼Œç„¶ååŠ è½½å¤©æ°”
                    fetchLocationName(userLatitude, userLongitude).then(() => {
                        // è·å–ä½ç½®åç§°åï¼ŒåŠ è½½å½“å‰ä½ç½®å¤©æ°”
                        loadWeatherByLocation(userLatitude, userLongitude);
                        loadingDiv.style.display = 'none';
                    });
                },
                function(error) {
                    console.error('è·å–ä½ç½®å¤±è´¥:', error);
                    alert('è·å–ä½ç½®å¤±è´¥: ' + error.message);
                    loadingDiv.style.display = 'none';
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 300000
                }
            );
        }

        // è·å–ä½ç½®åç§°
        async function fetchLocationName(lat, lon) {
            try {
                // å°è¯•ä½¿ç”¨å…è´¹çš„åå‘åœ°ç†ç¼–ç APIè·å–ä½ç½®åç§°
                // è¿™é‡Œä½¿ç”¨OpenStreetMapçš„Nominatim API (å…è´¹ï¼Œæ— éœ€API key)
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=zh-CN`);

                if (response.ok) {
                    const data = await response.json();
                    if (data && data.display_name) {
                        // æå–åŸå¸‚åç§°
                        const address = data.address || {};
                        const cityName = address.city || address.town || address.village || address.state || data.display_name.split(',')[0];
                        document.getElementById('location-name').textContent = cityName;
                        console.log('è·å–åˆ°ä½ç½®åç§°:', cityName);
                        return;
                    }
                }

                // å¦‚æœAPIå¤±è´¥ï¼Œä½¿ç”¨ç»çº¬åº¦åæ ‡
                throw new Error('APIå“åº”å¤±è´¥');
            } catch (error) {
                console.warn('è·å–ä½ç½®åç§°å¤±è´¥ï¼Œä½¿ç”¨ç»çº¬åº¦åæ ‡:', error);
                document.getElementById('location-name').textContent = `${lat.toFixed(4)}Â°, ${lon.toFixed(4)}Â°`;
            }
        }

        // æ˜¾ç¤ºåœ°ç‚¹è¾“å…¥é¢æ¿
        function showLocationPanel() {
            document.getElementById('location-panel').style.display = 'block';
            document.getElementById('input-latitude').focus();
        }

        // éšè—åœ°ç‚¹è¾“å…¥é¢æ¿
        function hideLocationPanel() {
            document.getElementById('location-panel').style.display = 'none';
            // æ¸…ç©ºè¾“å…¥
            document.getElementById('input-latitude').value = '';
            document.getElementById('input-longitude').value = '';
            document.getElementById('input-location-name').value = '';
        }

        // æ ‡è®°åœ°ç‚¹
        function markLocation() {
            const lat = parseFloat(document.getElementById('input-latitude').value);
            const lon = parseFloat(document.getElementById('input-longitude').value);
            const name = document.getElementById('input-location-name').value.trim();

            if (isNaN(lat) || isNaN(lon)) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ç»çº¬åº¦åæ ‡');
                return;
            }

            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                alert('ç»çº¬åº¦è¶…å‡ºæœ‰æ•ˆèŒƒå›´');
                return;
            }

            const locationName = name || `${lat.toFixed(4)}Â°, ${lon.toFixed(4)}Â°`;

            markLocationAt(lat, lon, locationName);
            moveCameraToLocation(lat, lon);
            hideLocationPanel();
        }

        // åœ¨æŒ‡å®šä½ç½®æ ‡è®°åœ°ç‚¹
        function markLocationAt(lat, lon, name) {
            // æ¸…é™¤ä¹‹å‰çš„æ ‡è®°
            clearLocationMarkers();

            // å°†ç»çº¬åº¦è½¬æ¢ä¸º3Dåæ ‡
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(Math.sin(phi) * Math.cos(theta));
            const z = Math.sin(phi) * Math.sin(theta);
            const y = Math.cos(phi);

            // åˆ›å»ºæ ‡è®°ç‚¹
            const markerGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.8
            });

            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x * 1.01, y * 1.01, z * 1.01);
            marker.userData = { lat, lon, name };
            scene.add(marker);
            locationMarkers.push(marker);

            // æ·»åŠ å‘å…‰æ•ˆæœ
            const glowGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(marker.position);
            scene.add(glow);
            locationMarkers.push(glow);

            // æ·»åŠ æ ‡ç­¾
            addLocationLabel(lat, lon, name);
        }

        // æ·»åŠ ä½ç½®æ ‡ç­¾
        function addLocationLabel(lat, lon, name) {
            // åˆ›å»ºHTMLæ ‡ç­¾
            const label = document.createElement('div');
            label.className = 'location-marker';
            label.textContent = name;
            label.style.position = 'absolute';
            label.style.color = '#ffffff';
            label.style.fontSize = '12px';
            label.style.fontWeight = 'bold';
            label.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            label.style.pointerEvents = 'none';
            label.style.zIndex = '600';
            document.body.appendChild(label);

            locationMarkers.push({ element: label, lat, lon, name });

            // æ›´æ–°æ ‡ç­¾ä½ç½®
            updateLocationLabels();
        }

        // æ›´æ–°ä½ç½®æ ‡ç­¾ä½ç½®
        function updateLocationLabels() {
            locationMarkers.forEach(marker => {
                if (marker.element && marker.lat !== undefined) {
                    const screenPos = getScreenPosition(marker.lat, marker.lon);
                    if (screenPos) {
                        marker.element.style.left = screenPos.x + 'px';
                        marker.element.style.top = screenPos.y + 'px';
                        marker.element.style.display = screenPos.visible ? 'block' : 'none';
                    }
                }
            });
        }

        // è·å–å±å¹•ä½ç½®
        function getScreenPosition(lat, lon) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(Math.sin(phi) * Math.cos(theta));
            const z = Math.sin(phi) * Math.sin(theta);
            const y = Math.cos(phi);

            const worldPos = new THREE.Vector3(x * 1.02, y * 1.02, z * 1.02);
            const screenPos = worldPos.clone();
            screenPos.project(camera);

            if (screenPos.z > 1 || screenPos.z < -1) {
                return { x: 0, y: 0, visible: false };
            }

            const xPos = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const yPos = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

            return { x: xPos, y: yPos, visible: true };
        }

        // ç§»åŠ¨ç›¸æœºåˆ°æŒ‡å®šä½ç½®
        function moveCameraToLocation(lat, lon) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(Math.sin(phi) * Math.cos(theta)) * 3;
            const z = Math.sin(phi) * Math.sin(theta) * 3;
            const y = Math.cos(phi) * 3;

            // å¹³æ»‘ç§»åŠ¨ç›¸æœº
            const targetPosition = new THREE.Vector3(x, y, z);
            const targetLookAt = new THREE.Vector3(
                -Math.sin(phi) * Math.cos(theta) * 1.01,
                Math.cos(phi) * 1.01,
                Math.sin(phi) * Math.sin(theta) * 1.01
            );

            // ä½¿ç”¨Tween.jsæˆ–ç®€å•åŠ¨ç”»
            animateCameraTo(targetPosition, targetLookAt);
        }

        // ç›¸æœºåŠ¨ç”»
        function animateCameraTo(targetPosition, targetLookAt) {
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();

            let animationProgress = 0;
            const animationDuration = 2000; // 2ç§’
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                animationProgress = Math.min(elapsed / animationDuration, 1);

                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const easeProgress = 1 - Math.pow(1 - animationProgress, 3);

                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                controls.target.lerpVectors(startTarget, targetLookAt, easeProgress);
                controls.update();

                if (animationProgress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        // æ¸…é™¤ä½ç½®æ ‡è®°
        function clearLocationMarkers() {
            locationMarkers.forEach(marker => {
                if (marker.element) {
                    document.body.removeChild(marker.element);
                } else if (marker.geometry) {
                    scene.remove(marker);
                }
            });
            locationMarkers = [];
        }

        // æ›´æ–°äº‘å›¾çŠ¶æ€æ˜¾ç¤º
        function updateCloudStatus(text, color = '#ffffff') {
            const statusElement = document.getElementById('cloud-status');
            if (statusElement) {
                statusElement.textContent = text;
                statusElement.style.color = color;
                // æ ¹æ®äº‘å±‚å¯è§æ€§æ§åˆ¶æ˜¾ç¤º
                statusElement.style.display = cloudsVisible ? 'block' : 'none';
            }
        }

        // åˆ‡æ¢äº‘å±‚æ˜¾ç¤º/éšè—
        function toggleClouds() {
            cloudsVisible = !cloudsVisible;

            if (window.cloudsMesh) {
                if (cloudsVisible) {
                    scene.add(window.cloudsMesh);
                    // é‡æ–°å¯åŠ¨é€æ˜åº¦åŠ¨ç”»
                    animateCloudOpacity();
                } else {
                    scene.remove(window.cloudsMesh);
                }
            }

            // æ›´æ–°æŒ‰é’®æ–‡æœ¬
            const buttons = document.querySelectorAll('.control-btn');
            buttons.forEach(button => {
                if (button.onclick && button.onclick.toString().includes('toggleClouds')) {
                    button.textContent = cloudsVisible ? 'â˜ï¸ éšè—äº‘å±‚' : 'â˜ï¸ æ˜¾ç¤ºäº‘å±‚';
                }
            });

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateCloudStatusVisibility();
        }

        // æ›´æ–°äº‘å±‚åˆ‡æ¢æŒ‰é’®çŠ¶æ€
        function updateCloudToggleButton() {
            const buttons = document.querySelectorAll('.control-btn');
            buttons.forEach(button => {
                if (button.onclick && button.onclick.toString().includes('toggleClouds')) {
                    button.textContent = cloudsVisible ? 'â˜ï¸ éšè—äº‘å±‚' : 'â˜ï¸ æ˜¾ç¤ºäº‘å±‚';
                }
            });
        }

        // æ›´æ–°äº‘å›¾çŠ¶æ€æ˜¾ç¤ºçš„å¯è§æ€§
        function updateCloudStatusVisibility() {
            const statusElement = document.getElementById('cloud-status');
            if (statusElement) {
                if (cloudsVisible) {
                    statusElement.style.display = 'block';
                } else {
                    statusElement.style.display = 'none';
                }
            }
        }

        // æ‰‹åŠ¨åˆ·æ–°äº‘å›¾
        function refreshClouds() {
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'â³ æ›´æ–°ä¸­...';
            button.disabled = true;

            loadSatelliteClouds()
                .then(() => {
                    button.textContent = 'âœ… äº‘å›¾å·²æ›´æ–°';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                })
                .catch(() => {
                    button.textContent = 'âŒ æ›´æ–°å¤±è´¥';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                });
        }

        // åˆå§‹åŒ–å¤©æ°”é¢„æŠ¥
        function initWeather() {
            // å»¶è¿ŸåŠ è½½å¤©æ°”æ•°æ®ï¼Œé¿å…é¡µé¢åˆæ¬¡åŠ è½½æ—¶é˜»å¡
            setTimeout(() => {
                loadWeatherData(currentCity);
            }, 2000);

            // æ¯30åˆ†é’Ÿè‡ªåŠ¨æ›´æ–°å¤©æ°”
            setInterval(() => {
                loadWeatherData(currentCity);
            }, 30 * 60 * 1000);
        }

        // åŠ è½½å¤©æ°”æ•°æ®
        function loadWeatherData(city) {
            console.log('æ­£åœ¨åŠ è½½å¤©æ°”æ•°æ®:', city);

            // é¦–å…ˆå°è¯•æ ¹æ®åŸå¸‚åç§°è·å–åæ ‡ï¼Œç„¶åä½¿ç”¨Open-Meteo API
            getCityCoordinates(city)
                .then(coords => {
                    if (coords) {
                        return loadWeatherFromOpenMeteo(coords.lat, coords.lon, city);
                    } else {
                        throw new Error('æ— æ³•è·å–åŸå¸‚åæ ‡');
                    }
                })
                .then(data => {
                    console.log('å¤©æ°”æ•°æ®åŠ è½½æˆåŠŸ:', data);
                    weatherData = data;
                    updateWeatherDisplayFromOpenMeteo(data, city);
                    document.getElementById('weather-display').style.display = 'block';
                })
                .catch(error => {
                    console.error('å¤©æ°”æ•°æ®åŠ è½½å¤±è´¥:', error);
                    // å¦‚æœAPIå¤±è´¥ï¼Œæ˜¾ç¤ºæ¨¡æ‹Ÿæ•°æ®
                    showMockWeather(city);
                });
        }

        // è·å–åŸå¸‚åæ ‡ï¼ˆç”¨äºOpen-Meteo APIï¼‰
        function getCityCoordinates(city) {
            return new Promise((resolve, reject) => {
                // ç®€å•çš„åŸå¸‚åæ ‡æ˜ å°„ï¼ˆä¸»è¦åŸå¸‚ï¼‰
                const cityCoords = {
                    'åŒ—äº¬': { lat: 39.9042, lon: 116.4074 },
                    'ä¸Šæµ·': { lat: 31.2304, lon: 121.4737 },
                    'å¹¿å·': { lat: 23.1291, lon: 113.2644 },
                    'æ·±åœ³': { lat: 22.5431, lon: 114.0579 },
                    'æ­å·': { lat: 30.2741, lon: 120.1551 },
                    'å—äº¬': { lat: 32.0603, lon: 118.7969 },
                    'æˆéƒ½': { lat: 30.5728, lon: 104.0668 },
                    'æ­¦æ±‰': { lat: 30.5928, lon: 114.3055 },
                    'è¥¿å®‰': { lat: 34.3416, lon: 108.9398 },
                    'æ²ˆé˜³': { lat: 41.8057, lon: 123.4315 },
                    'Tokyo': { lat: 35.6762, lon: 139.6503 },
                    'New York': { lat: 40.7128, lon: -74.0060 },
                    'London': { lat: 51.5074, lon: -0.1278 },
                    'Sydney': { lat: -33.8688, lon: 151.2093 },
                    'Paris': { lat: 48.8566, lon: 2.3522 },
                    'Berlin': { lat: 52.5200, lon: 13.4050 },
                    'Moscow': { lat: 55.7558, lon: 37.6173 },
                    'Singapore': { lat: 1.3521, lon: 103.8198 }
                };

                // æ£€æŸ¥æ˜¯å¦æ˜¯åæ ‡æ ¼å¼ (lat,lon)
                const coordMatch = city.match(/^(-?\d+\.?\d*),?\s*(-?\d+\.?\d*)$/);
                if (coordMatch) {
                    const lat = parseFloat(coordMatch[1]);
                    const lon = parseFloat(coordMatch[2]);
                    resolve({ lat, lon });
                    return;
                }

                // æ£€æŸ¥é¢„å®šä¹‰åŸå¸‚
                if (cityCoords[city]) {
                    resolve(cityCoords[city]);
                    return;
                }

                // å¦‚æœæ‰¾ä¸åˆ°ï¼Œä½¿ç”¨é»˜è®¤åæ ‡ï¼ˆåŒ—äº¬ï¼‰
                console.warn('æœªæ‰¾åˆ°åŸå¸‚åæ ‡ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®ï¼ˆåŒ—äº¬ï¼‰');
                resolve(cityCoords['åŒ—äº¬']);
            });
        }

        // ä½¿ç”¨Open-Meteo APIåŠ è½½å¤©æ°”æ•°æ®ï¼ˆå®Œå…¨å…è´¹ï¼Œæ— éœ€API keyï¼‰
        function loadWeatherFromOpenMeteo(lat, lon, cityName) {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,weathercode,windspeed_10m_max,winddirection_10m_dominant&timezone=auto&forecast_days=3`;

            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Open-Meteo APIè¯·æ±‚å¤±è´¥');
                    }
                    return response.json();
                });
        }

        // æ›´æ–°å¤©æ°”æ˜¾ç¤º (å…¼å®¹Open-Meteoæ•°æ®æ ¼å¼)
        function updateWeatherDisplayFromOpenMeteo(data, cityName) {
            try {
                const current = data.current_weather;
                const daily = data.daily;

                // æ›´æ–°ä½ç½®åç§°
                document.getElementById('location-name').textContent = cityName;

                // å½“å‰å¤©æ°”
                document.getElementById('weather-icon').textContent = getWeatherIconOpenMeteo(current.weathercode);
                document.getElementById('weather-temp').textContent = Math.round(current.temperature) + 'Â°C';
                document.getElementById('weather-condition').textContent = getWeatherDescriptionOpenMeteo(current.weathercode);
                document.getElementById('weather-wind').textContent = `é£é€Ÿ: ${Math.round(current.windspeed)}km/h`;

                // é¢„æŠ¥ (ä»Šå¤©å’Œæ˜å¤©)
                if (daily && daily.temperature_2m_max && daily.temperature_2m_max.length >= 2) {
                    // ä»Šå¤©
                    const todayMax = Math.round(daily.temperature_2m_max[0]);
                    const todayMin = Math.round(daily.temperature_2m_min[0]);
                    const todayCode = daily.weathercode[0];

                    document.querySelector('#forecast-today .forecast-icon').textContent = getWeatherIconOpenMeteo(todayCode);
                    document.querySelector('#forecast-today .forecast-temp').textContent = `${todayMin}Â°/${todayMax}Â°`;

                    // æ˜å¤©
                    const tomorrowMax = Math.round(daily.temperature_2m_max[1]);
                    const tomorrowMin = Math.round(daily.temperature_2m_min[1]);
                    const tomorrowCode = daily.weathercode[1];

                    document.querySelector('#forecast-tomorrow .forecast-icon').textContent = getWeatherIconOpenMeteo(tomorrowCode);
                    document.querySelector('#forecast-tomorrow .forecast-temp').textContent = `${tomorrowMin}Â°/${tomorrowMax}Â°`;
                }
            } catch (error) {
                console.error('æ›´æ–°Open-Meteoå¤©æ°”æ˜¾ç¤ºå¤±è´¥:', error);
                showMockWeather(cityName);
            }
        }

        // è·å–å¤©æ°”å›¾æ ‡ (å…¼å®¹Open-Meteo WMOä»£ç )
        function getWeatherIconOpenMeteo(weathercode) {
            // Open-Meteo WMOå¤©æ°”ä»£ç æ˜ å°„åˆ°emoji
            const iconMap = {
                0: 'â˜€ï¸',   // Clear sky
                1: 'ğŸŒ¤ï¸',   // Mainly clear
                2: 'â›…',   // Partly cloudy
                3: 'â˜ï¸',   // Overcast
                45: 'ğŸŒ«ï¸',  // Fog
                48: 'ğŸŒ«ï¸',  // Depositing rime fog
                51: 'ğŸŒ§ï¸',  // Light drizzle
                53: 'ğŸŒ§ï¸',  // Moderate drizzle
                55: 'ğŸŒ§ï¸',  // Dense drizzle
                56: 'ğŸŒ§ï¸',  // Light freezing drizzle
                57: 'ğŸŒ§ï¸',  // Dense freezing drizzle
                61: 'ğŸŒ§ï¸',  // Slight rain
                63: 'ğŸŒ§ï¸',  // Moderate rain
                65: 'ğŸŒ§ï¸',  // Heavy rain
                66: 'ğŸŒ§ï¸',  // Light freezing rain
                67: 'ğŸŒ§ï¸',  // Heavy freezing rain
                71: 'ğŸŒ¨ï¸',  // Slight snow fall
                73: 'ğŸŒ¨ï¸',  // Moderate snow fall
                75: 'â„ï¸',  // Heavy snow fall
                77: 'ğŸŒ¨ï¸',  // Snow grains
                80: 'ğŸŒ¦ï¸',  // Slight rain showers
                81: 'ğŸŒ¦ï¸',  // Moderate rain showers
                82: 'ğŸŒ¦ï¸',  // Violent rain showers
                85: 'ğŸŒ¨ï¸',  // Slight snow showers
                86: 'â„ï¸',  // Heavy snow showers
                95: 'â›ˆï¸',  // Thunderstorm
                96: 'â›ˆï¸',  // Thunderstorm with slight hail
                99: 'â›ˆï¸'   // Thunderstorm with heavy hail
            };

            return iconMap[weathercode] || 'ğŸŒ¤ï¸';
        }

        // è·å–å¤©æ°”æè¿° (Open-Meteo)
        function getWeatherDescriptionOpenMeteo(weathercode) {
            const descriptionMap = {
                0: 'æ™´æœ—',
                1: 'å¤§éƒ¨æ™´æœ—',
                2: 'å±€éƒ¨å¤šäº‘',
                3: 'é˜´å¤©',
                45: 'æœ‰é›¾',
                48: 'é›¾å‡‡',
                51: 'å°æ¯›æ¯›é›¨',
                53: 'æ¯›æ¯›é›¨',
                55: 'å¤§æ¯›æ¯›é›¨',
                56: 'å°å†»æ¯›æ¯›é›¨',
                57: 'å†»æ¯›æ¯›é›¨',
                61: 'å°é›¨',
                63: 'ä¸­é›¨',
                65: 'å¤§é›¨',
                66: 'å°å†»é›¨',
                67: 'å†»é›¨',
                71: 'å°é›ª',
                73: 'ä¸­é›ª',
                75: 'å¤§é›ª',
                77: 'é›ªç²’',
                80: 'å°é˜µé›¨',
                81: 'é˜µé›¨',
                82: 'å¼ºé˜µé›¨',
                85: 'å°é˜µé›ª',
                86: 'é˜µé›ª',
                95: 'é›·æš´',
                96: 'é›·æš´ä¼´å†°é›¹',
                99: 'å¼ºé›·æš´ä¼´å†°é›¹'
            };

            return descriptionMap[weathercode] || 'æœªçŸ¥';
        }

        // æ˜¾ç¤ºæ¨¡æ‹Ÿå¤©æ°”æ•°æ®ï¼ˆå½“APIä¸å¯ç”¨æ—¶ï¼‰
        function showMockWeather(city) {
            console.log('æ˜¾ç¤ºæ¨¡æ‹Ÿå¤©æ°”æ•°æ® for:', city);

            document.getElementById('location-name').textContent = city;
            document.getElementById('weather-display').style.display = 'block';

            // æ ¹æ®åŸå¸‚å’Œå­£èŠ‚ç”Ÿæˆæ›´çœŸå®çš„æ¨¡æ‹Ÿæ•°æ®
            const now = new Date();
            const month = now.getMonth() + 1; // 1-12
            const isSummer = month >= 6 && month <= 8;
            const isWinter = month >= 12 || month <= 2;

            let temp, condition, icon, windSpeed;

            // æ ¹æ®å­£èŠ‚è°ƒæ•´æ¸©åº¦
            if (isSummer) {
                temp = 28 + Math.floor(Math.random() * 8); // 28-35Â°C
                condition = Math.random() > 0.3 ? 'æ™´æœ—' : 'å¤šäº‘';
                icon = Math.random() > 0.3 ? 'â˜€ï¸' : 'â›…';
            } else if (isWinter) {
                temp = 0 + Math.floor(Math.random() * 10); // 0-10Â°C
                condition = Math.random() > 0.4 ? 'æ™´æœ—' : Math.random() > 0.5 ? 'å¤šäº‘' : 'å°é›ª';
                icon = condition === 'å°é›ª' ? 'ğŸŒ¨ï¸' : Math.random() > 0.4 ? 'â˜€ï¸' : 'â›…';
            } else {
                temp = 15 + Math.floor(Math.random() * 15); // 15-30Â°C
                condition = Math.random() > 0.4 ? 'æ™´æœ—' : Math.random() > 0.5 ? 'å¤šäº‘' : 'å°é›¨';
                icon = condition === 'å°é›¨' ? 'ğŸŒ§ï¸' : Math.random() > 0.4 ? 'â˜€ï¸' : 'â›…';
            }

            windSpeed = 5 + Math.floor(Math.random() * 20); // 5-25km/h

            // å½“å‰å¤©æ°”
            document.getElementById('weather-icon').textContent = icon;
            document.getElementById('weather-temp').textContent = temp + 'Â°C';
            document.getElementById('weather-condition').textContent = condition;
            document.getElementById('weather-wind').textContent = `é£é€Ÿ: ${windSpeed}km/h`;

            // æ¨¡æ‹Ÿé¢„æŠ¥
            const todayMin = temp - 5 - Math.floor(Math.random() * 5);
            const todayMax = temp + 3 + Math.floor(Math.random() * 5);
            const tomorrowMin = temp - 3 - Math.floor(Math.random() * 4);
            const tomorrowMax = temp + 1 + Math.floor(Math.random() * 4);

            document.querySelector('#forecast-today .forecast-icon').textContent = icon;
            document.querySelector('#forecast-today .forecast-temp').textContent = `${todayMin}Â°/${todayMax}Â°`;

            document.querySelector('#forecast-tomorrow .forecast-icon').textContent = Math.random() > 0.5 ? 'â›…' : 'â˜ï¸';
            document.querySelector('#forecast-tomorrow .forecast-temp').textContent = `${tomorrowMin}Â°/${tomorrowMax}Â°`;

            console.log(`æ¨¡æ‹Ÿå¤©æ°” - ${city}: ${temp}Â°C, ${condition}, é£é€Ÿ${windSpeed}km/h`);
        }

        // æ˜¾ç¤ºåŸå¸‚é€‰æ‹©é¢æ¿
        function showCitySelector() {
            document.getElementById('city-selector-panel').style.display = 'block';
            document.getElementById('city-search').focus();
        }

        // éšè—åŸå¸‚é€‰æ‹©é¢æ¿
        function hideCitySelector() {
            document.getElementById('city-selector-panel').style.display = 'none';
            document.getElementById('city-search').value = '';
        }

        // é€‰æ‹©åŸå¸‚
        function selectCity(city) {
            currentCity = city;
            document.getElementById('city-search').value = city;

            // è·å–åŸå¸‚åæ ‡å¹¶æ›´æ–°å½“å‰ä½ç½®
            getCityCoordinates(city).then(coords => {
                if (coords) {
                    currentLocationLat = coords.lat;
                    currentLocationLon = coords.lon;

                    // ä¿å­˜è®¾ç½®
                    saveUserSettings();

                    // åŠ è½½å¤©æ°”æ•°æ®
                    loadWeatherData(city);

                    // æ·»åŠ æ ‡è®°
                    markLocationAt(coords.lat, coords.lon, city);

                    // ç§»åŠ¨ç›¸æœºåˆ°åŸå¸‚ä½ç½®
                    moveCameraToLocation(coords.lat, coords.lon);
                }
            });

            hideCitySelector();
        }

        // æœç´¢åŸå¸‚å¤©æ°”
        function searchWeatherByCity() {
            const cityInput = document.getElementById('city-search').value.trim();
            if (cityInput) {
                currentCity = cityInput;

                // è·å–åŸå¸‚åæ ‡å¹¶æ›´æ–°å½“å‰ä½ç½®
                getCityCoordinates(cityInput).then(coords => {
                    if (coords) {
                        currentLocationLat = coords.lat;
                        currentLocationLon = coords.lon;

                        // ä¿å­˜è®¾ç½®
                        saveUserSettings();

                        // åŠ è½½å¤©æ°”æ•°æ®
                        loadWeatherData(cityInput);

                        // æ·»åŠ æ ‡è®°
                        markLocationAt(coords.lat, coords.lon, cityInput);

                        // ç§»åŠ¨ç›¸æœºåˆ°åŸå¸‚ä½ç½®
                        moveCameraToLocation(coords.lat, coords.lon);
                    } else {
                        // å¦‚æœæ‰¾ä¸åˆ°åæ ‡ï¼Œä½¿ç”¨é»˜è®¤å€¼
                        console.warn('æ— æ³•è·å–åŸå¸‚åæ ‡ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®');
                        currentLocationLat = 39.9042; // åŒ—äº¬
                        currentLocationLon = 116.4074;
                    }
                });

                hideCitySelector();
            }
        }

        // æ ¹æ®åœ°ç†ä½ç½®è·å–å¤©æ°”ï¼ˆå½“è·å–åˆ°ç”¨æˆ·ä½ç½®æ—¶è°ƒç”¨ï¼‰
        function loadWeatherByLocation(lat, lon) {
            console.log('æ ¹æ®ä½ç½®åŠ è½½å¤©æ°”:', lat, lon);

            // è·å–å½“å‰ä½ç½®çš„å‹å¥½åç§°
            const locationElement = document.getElementById('location-name');
            const locationName = locationElement ? locationElement.textContent : `ä½ç½® (${lat.toFixed(2)}, ${lon.toFixed(2)})`;

            // ç›´æ¥ä½¿ç”¨åæ ‡è°ƒç”¨Open-Meteo API
            loadWeatherFromOpenMeteo(lat, lon, locationName)
                .then(data => {
                    console.log('ä½ç½®å¤©æ°”æ•°æ®åŠ è½½æˆåŠŸ:', data);
                    weatherData = data;
                    updateWeatherDisplayFromOpenMeteo(data, locationName);
                    document.getElementById('weather-display').style.display = 'block';
                })
                .catch(error => {
                    console.error('ä½ç½®å¤©æ°”æ•°æ®åŠ è½½å¤±è´¥:', error);
                    showMockWeather(locationName);
                });
        }

        // æ›´æ–°æ—¥å¤œå¾ªç¯
        function updateDayNightCycle() {
            if (!sunLight) return;

            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();

            // è®¡ç®—å¤ªé˜³ä½ç½® (åŸºäºæ—¶é—´)
            const totalSeconds = hours * 3600 + minutes * 60 + seconds;
            const dayProgress = (totalSeconds / 86400) * Math.PI * 2; // ä¸€å¤©çš„è¿›åº¦è½¬æ¢ä¸ºå¼§åº¦

            // å¤ªé˜³é«˜åº¦ (ä»-1åˆ°1)
            const sunHeight = Math.sin(dayProgress - Math.PI / 2);

            // å¤ªé˜³æ–¹ä½è§’
            const sunAzimuth = dayProgress;

            // æ›´æ–°å¤ªé˜³ä½ç½®
            const sunDistance = 10;
            sunLight.position.x = Math.cos(sunAzimuth) * Math.cos(sunHeight) * sunDistance;
            sunLight.position.y = Math.sin(sunHeight) * sunDistance;
            sunLight.position.z = Math.sin(sunAzimuth) * Math.cos(sunHeight) * sunDistance;

            // æ ¹æ®å¤ªé˜³é«˜åº¦è°ƒæ•´å…‰ç…§å¼ºåº¦
            const lightIntensity = Math.max(0.3, Math.sin(sunHeight) * 0.8 + 0.4);
            sunLight.intensity = lightIntensity;

            // æ›´æ–°ç¯å¢ƒå…‰å¼ºåº¦
            const ambientIntensity = Math.max(0.2, Math.sin(sunHeight) * 0.2 + 0.3);

            // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡
            setTimeout(updateDayNightCycle, 60000);
        }

        // åŠ è½½å®æ—¶å«æ˜Ÿäº‘å›¾
        function loadSatelliteClouds() {
            console.log('æ­£åœ¨åŠ è½½å®æ—¶å«æ˜Ÿäº‘å›¾...');
            updateCloudStatus('â˜ï¸ äº‘å›¾: åŠ è½½ä¸­...', '#ffff00');

            // æ£€æµ‹æ˜¯å¦æœ‰å°é£ç­‰æç«¯å¤©æ°”äº‹ä»¶
            checkForExtremeWeather()
                .then(hasExtremeWeather => {
                    console.log('æç«¯å¤©æ°”æ£€æµ‹ç»“æœ:', hasExtremeWeather ? 'å‘ç°å°é£/æç«¯å¤©æ°”' : 'æ— æç«¯å¤©æ°”');

                    // æ ¹æ®æ˜¯å¦æœ‰æç«¯å¤©æ°”é€‰æ‹©æ•°æ®æºä¼˜å…ˆçº§
                    let loadPromises;
                    if (hasExtremeWeather) {
                        // å°é£ç­‰æç«¯å¤©æ°”ï¼šä¼˜å…ˆä½¿ç”¨èƒ½æ˜¾ç¤ºå…¨çƒèŒƒå›´çš„å®æ—¶æ•°æ®
                        loadPromises = [
                            loadJMAClouds(), // æ—¥æœ¬æ°”è±¡å… - äºšæ´²å°é£
                            loadGOESGlobalClouds(), // NOAA GOESå…¨çƒ
                            loadNOAAClouds(), // NASA GIBS
                            loadEUMETSATClouds(), // æ¬§æ´²å«æ˜Ÿ
                            loadOpenWeatherClouds(), // Windyå®æ—¶äº‘å›¾
                        ];
                    } else {
                        // æ­£å¸¸å¤©æ°”ï¼šä½¿ç”¨æœ€å¯é çš„æ•°æ®æº
                        loadPromises = [
                            loadNOAAClouds(), // NASA GIBS (æœ€ç¨³å®š)
                            loadJMAClouds(), // æ—¥æœ¬æ°”è±¡å…
                            loadOpenWeatherClouds(), // Windyå®æ—¶
                            loadGOESGlobalClouds(), // NOAA GOES
                            loadEUMETSATClouds(), // æ¬§æ´²å«æ˜Ÿ
                        ];
                    }

                    // ä¾æ¬¡å°è¯•æ•°æ®æº
                    return loadPromises.reduce((promise, nextPromise) => {
                        return promise.catch(() => nextPromise);
                    }, Promise.reject());
                })
                .then(() => {
                    updateCloudStatus('â˜ï¸ äº‘å›¾: å®æ—¶å«æ˜Ÿ', '#00ff00');
                    console.log('å®æ—¶å«æ˜Ÿäº‘å›¾åŠ è½½å®Œæˆ');
                })
                .catch(() => {
                    // æ‰€æœ‰å®æ—¶æ•°æ®æºéƒ½å¤±è´¥ï¼Œä½¿ç”¨é™æ€äº‘å›¾
                    console.log('æ‰€æœ‰å®æ—¶äº‘å›¾æ•°æ®æºå¤±è´¥ï¼Œä½¿ç”¨é™æ€äº‘å›¾');
                    return loadStaticClouds();
                })
                .then(() => {
                    updateCloudStatus('â˜ï¸ äº‘å›¾: é™æ€äº‘å›¾', '#ffa500');
                })
                .catch((error) => {
                    console.error('æ‰€æœ‰äº‘å›¾æ•°æ®æºéƒ½å¤±è´¥:', error);
                    updateCloudStatus('â˜ï¸ äº‘å›¾: åŠ è½½å¤±è´¥', '#ff4444');
                });
        }

        // æ£€æµ‹æ˜¯å¦æœ‰å°é£ç­‰æç«¯å¤©æ°”äº‹ä»¶
        function checkForExtremeWeather() {
            return new Promise((resolve) => {
                // ç›®å‰ä½¿ç”¨å­£èŠ‚æ€§æ£€æµ‹ + éšæœºå› ç´ æ¨¡æ‹Ÿå°é£æ£€æµ‹
                const currentMonth = new Date().getMonth() + 1; // 1-12
                const isTyphoonSeason = currentMonth >= 6 && currentMonth <= 11;

                // åœ¨å°é£å­£èŠ‚ï¼Œæœ‰æ›´é«˜æ¦‚ç‡æ£€æµ‹åˆ°"æç«¯å¤©æ°”"
                // è¿™å¯ä»¥è®©ç³»ç»Ÿåœ¨å°é£å­£èŠ‚ä¼˜å…ˆä½¿ç”¨å®æ—¶æ•°æ®æº
                const randomFactor = Math.random();
                const hasExtremeWeather = isTyphoonSeason && randomFactor < 0.7; // å°é£å­£èŠ‚70%æ¦‚ç‡

                console.log(`å¤©æ°”æ£€æµ‹ - æœˆä»½:${currentMonth}, å°é£å­£èŠ‚:${isTyphoonSeason}, æç«¯å¤©æ°”:${hasExtremeWeather}`);

                // æ›´æ–°å¤©æ°”è­¦æŠ¥æ˜¾ç¤º
                updateWeatherAlert(hasExtremeWeather, isTyphoonSeason);

                resolve(hasExtremeWeather);

                // æœªæ¥å¯ä»¥é›†æˆçœŸå®çš„å°é£æ£€æµ‹APIï¼Œæ¯”å¦‚ï¼š
                // 1. JTWC (è”åˆå°é£è­¦æŠ¥ä¸­å¿ƒ): https://www.metoc.navy.mil/jtwc/jtwc.html
                // 2. JMAå°é£æ•°æ®: https://www.jma.go.jp/jma/index.html
                // 3. NOAAé£æš´è·Ÿè¸ª: https://www.noaa.gov/
                // 4. é¦™æ¸¯å¤©æ–‡å°: https://www.hko.gov.hk/
            });
        }

        // æ›´æ–°å¤©æ°”è­¦æŠ¥æ˜¾ç¤º
        function updateWeatherAlert(hasExtremeWeather, isTyphoonSeason) {
            const alertElement = document.getElementById('weather-alert');
            if (!alertElement) return;

            if (hasExtremeWeather) {
                alertElement.textContent = 'ğŸŒªï¸ å°é£å­£èŠ‚ - å¢å¼ºç›‘æµ‹';
                alertElement.style.color = '#ff4444';
            } else if (isTyphoonSeason) {
                alertElement.textContent = 'ğŸŒ¦ï¸ å°é£å­£èŠ‚';
                alertElement.style.color = '#ffaa00';
            } else {
                alertElement.textContent = 'â˜€ï¸ æ­£å¸¸å¤©æ°”';
                alertElement.style.color = '#00aa00';
            }
        }

        // åŠ è½½NASA GIBSå…¨çƒå«æ˜Ÿäº‘å›¾
        function loadNOAAClouds() {
            return new Promise((resolve, reject) => {
                try {
                    // ä½¿ç”¨NASA GIBS (Global Imagery Browse Services) è·å–MODISäº‘å›¾
                    // è®¡ç®—æœ€è¿‘çš„å¯ç”¨æ—¶é—´ (MODISæ•°æ®å¤§çº¦æ¯5å¤©æ›´æ–°ä¸€æ¬¡æœ€æ–°æ•°æ®)
                    const now = new Date();
                    const currentDate = new Date(now.getTime() - (24 * 60 * 60 * 1000)); // ä½¿ç”¨æ˜¨å¤©çš„æ•°æ®ï¼ˆæ›´ç¨³å®šï¼‰

                    const year = currentDate.getUTCFullYear();
                    const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
                    const day = String(currentDate.getUTCDate()).padStart(2, '0');

                    // NASA GIBSäº‘å›¾URL (å…¨çƒè¦†ç›–)
                    const nasaUrl = `https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/MODIS_Terra_Cloud_Top_Temp_Day/default/${year}-${month}-${day}/EPSG4326_250m/${year}-${month}-${day}.jpg`;

                    console.log('å°è¯•åŠ è½½NASA GIBSäº‘å›¾:', nasaUrl);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.crossOrigin = 'anonymous';

                    textureLoader.load(
                        nasaUrl,
                        function(texture) {
                            console.log('NASA GIBSäº‘å›¾åŠ è½½æˆåŠŸ');
                            updateCloudTexture(texture);
                            resolve(texture);
                        },
                        function(progress) {
                            console.log('NASAäº‘å›¾åŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function(err) {
                            console.log('NASA GIBSäº‘å›¾åŠ è½½å¤±è´¥ï¼Œå°è¯•JMAå«æ˜Ÿäº‘å›¾');
                            // å¦‚æœNASAå¤±è´¥ï¼Œå°è¯•JMA
                            loadJMAClouds().then(resolve).catch(reject);
                        }
                    );
                } catch (error) {
                    console.error('NASAäº‘å›¾URLç”Ÿæˆå¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // åŠ è½½JMAï¼ˆæ—¥æœ¬æ°”è±¡å…ï¼‰Himawariå«æ˜Ÿäº‘å›¾
        function loadJMAClouds() {
            return new Promise((resolve, reject) => {
                try {
                    // JMA Himawariå«æ˜Ÿæä¾›äºšæ´²åŒºåŸŸçš„å®æ—¶äº‘å›¾
                    const now = new Date();
                    const year = now.getUTCFullYear();
                    const month = String(now.getUTCMonth() + 1).padStart(2, '0');
                    const day = String(now.getUTCDate()).padStart(2, '0');
                    const hour = String(now.getUTCHours()).padStart(2, '0');
                    const minute = String(Math.floor(now.getUTCMinutes() / 10) * 10).padStart(2, '0'); // 10åˆ†é’Ÿé—´éš”

                    // JMA Himawariå«æ˜Ÿäº‘å›¾ (äºšæ´²åŒºåŸŸï¼ŒåŒ…å«å°é£ç­‰)
                    const jmaUrl = `https://www.jma.go.jp/bosai/himawari/data/satimg/${year}${month}${day}${hour}${minute}/b13/B13_${year}${month}${day}${hour}${minute}.jpg`;

                    console.log('å°è¯•åŠ è½½JMAå«æ˜Ÿäº‘å›¾:', jmaUrl);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.crossOrigin = 'anonymous';

                    textureLoader.load(
                        jmaUrl,
                        function(texture) {
                            console.log('JMAå«æ˜Ÿäº‘å›¾åŠ è½½æˆåŠŸ');
                            updateCloudTexture(texture);
                            resolve(texture);
                        },
                        function(progress) {
                            console.log('JMAäº‘å›¾åŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function(err) {
                            console.log('JMAå«æ˜Ÿäº‘å›¾åŠ è½½å¤±è´¥ï¼Œå°è¯•EUMETSAT');
                            // å¦‚æœJMAå¤±è´¥ï¼Œå°è¯•EUMETSAT
                            loadEUMETSATClouds().then(resolve).catch(reject);
                        }
                    );
                } catch (error) {
                    console.error('JMAäº‘å›¾URLç”Ÿæˆå¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // åŠ è½½EUMETSAT MSGå«æ˜Ÿäº‘å›¾
        function loadEUMETSATClouds() {
            return new Promise((resolve, reject) => {
                try {
                    // EUMETSAT MSGå«æ˜Ÿäº‘å›¾ (æ¬§æ´²å’Œéæ´²åŒºåŸŸ)
                    const now = new Date();
                    const year = now.getUTCFullYear();
                    const month = String(now.getUTCMonth() + 1).padStart(2, '0');
                    const day = String(now.getUTCDate()).padStart(2, '0');
                    const hour = String(now.getUTCHours()).padStart(2, '0');

                    // EUMETSATå…¬å¼€çš„å«æ˜Ÿå›¾åƒ
                    const eumetsatUrl = `https://eumetview.eumetsat.int/static-images/MSG/RGB/AIRMASS/MSG_AIRMASS_${year}${month}${day}${hour}00.png`;

                    console.log('å°è¯•åŠ è½½EUMETSATå«æ˜Ÿäº‘å›¾:', eumetsatUrl);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.crossOrigin = 'anonymous';

                    textureLoader.load(
                        eumetsatUrl,
                        function(texture) {
                            console.log('EUMETSATå«æ˜Ÿäº‘å›¾åŠ è½½æˆåŠŸ');
                            updateCloudTexture(texture);
                            resolve(texture);
                        },
                        function(progress) {
                            console.log('EUMETSATäº‘å›¾åŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function(err) {
                            console.log('EUMETSATå«æ˜Ÿäº‘å›¾åŠ è½½å¤±è´¥ï¼Œå°è¯•Windyäº‘å›¾');
                            reject(err);
                        }
                    );
                } catch (error) {
                    console.error('EUMETSATäº‘å›¾URLç”Ÿæˆå¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // åŠ è½½Windyå®æ—¶äº‘å›¾
        function loadOpenWeatherClouds() {
            return new Promise((resolve, reject) => {
                try {
                    // ä½¿ç”¨Windyçš„å®æ—¶äº‘å›¾æœåŠ¡ (å…¨çƒè¦†ç›–ï¼ŒåŒ…æ‹¬å°é£ç­‰æç«¯å¤©æ°”)
                    // Windyæä¾›å¤šç§äº‘å›¾å±‚çº§ï¼Œè¿™é‡Œä½¿ç”¨ clouds å›¾å±‚
                    const windyUrl = 'https://tiles.windy.com/tiles/v9.0/clouds/0/0/0.png';

                    console.log('å°è¯•åŠ è½½Windyå®æ—¶äº‘å›¾:', windyUrl);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.crossOrigin = 'anonymous';

                    textureLoader.load(
                        windyUrl,
                        function(texture) {
                            console.log('Windyå®æ—¶äº‘å›¾åŠ è½½æˆåŠŸ');
                            updateCloudTexture(texture);
                            resolve(texture);
                        },
                        function(progress) {
                            console.log('Windyäº‘å›¾åŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function(err) {
                            console.log('Windyäº‘å›¾åŠ è½½å¤±è´¥ï¼Œå°è¯•NOAA GOESå…¨çƒäº‘å›¾');
                            // å°è¯•NOAAçš„å…¨çƒGOESå«æ˜Ÿäº‘å›¾
                            loadGOESGlobalClouds().then(resolve).catch(reject);
                        }
                    );
                } catch (error) {
                    console.error('Windyäº‘å›¾URLç”Ÿæˆå¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // åŠ è½½NOAA GOESå…¨çƒå«æ˜Ÿäº‘å›¾
        function loadGOESGlobalClouds() {
            return new Promise((resolve, reject) => {
                try {
                    // NOAA GOESå«æ˜Ÿçš„å…¨çƒåˆæˆäº‘å›¾
                    const now = new Date();
                    const year = now.getUTCFullYear();
                    const month = String(now.getUTCMonth() + 1).padStart(2, '0');
                    const day = String(now.getUTCDate()).padStart(2, '0');
                    const hour = String(now.getUTCHours()).padStart(2, '0');
                    const minute = String(Math.floor(now.getUTCMinutes() / 15) * 15).padStart(2, '0'); // 15åˆ†é’Ÿé—´éš”

                    // GOESå…¨çƒäº‘å›¾
                    const goesUrl = `https://cdn.star.nesdis.noaa.gov/GOES16/ABI/GLOBAL/GEOCOLOR/${year}${month}${day}_${hour}${minute}00.jpg`;

                    console.log('å°è¯•åŠ è½½NOAA GOESå…¨çƒäº‘å›¾:', goesUrl);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.crossOrigin = 'anonymous';

                    textureLoader.load(
                        goesUrl,
                        function(texture) {
                            console.log('NOAA GOESå…¨çƒäº‘å›¾åŠ è½½æˆåŠŸ');
                            updateCloudTexture(texture);
                            resolve(texture);
                        },
                        function(progress) {
                            console.log('GOESäº‘å›¾åŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function(err) {
                            console.log('NOAA GOESå…¨çƒäº‘å›¾åŠ è½½å¤±è´¥');
                            reject(err);
                        }
                    );
                } catch (error) {
                    console.error('GOESäº‘å›¾URLç”Ÿæˆå¤±è´¥:', error);
                    reject(error);
                }
            });
        }

        // åŠ è½½é«˜è´¨é‡é™æ€äº‘å›¾ä½œä¸ºåå¤‡
        function loadStaticClouds() {
            return new Promise((resolve, reject) => {
                // ä½¿ç”¨é«˜è´¨é‡çš„é™æ€åœ°çƒäº‘å›¾
                const staticUrls = [
                    // NASA Blue Marbleäº‘å›¾ (é«˜è´¨é‡)
                    'https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg',
                    // Three.jså®˜æ–¹äº‘å›¾
                    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_2048.png',
                    // å¤‡ç”¨äº‘å›¾
                    'https://raw.githubusercontent.com/jeromeetienne/threex.planets/master/images/earthcloudmap.jpg',
                    // ç¨‹åºåŒ–äº‘å›¾ä½œä¸ºæœ€ååå¤‡
                    'procedural'
                ];

                let loaded = false;
                let loadAttempts = 0;

                function tryNextUrl() {
                    if (loaded || loadAttempts >= staticUrls.length) {
                        if (!loaded) {
                            createProceduralClouds();
                            resolve(null);
                        }
                        return;
                    }

                    const url = staticUrls[loadAttempts];
                    loadAttempts++;

                    if (url === 'procedural') {
                        // ä½¿ç”¨ç¨‹åºåŒ–äº‘å›¾
                        createProceduralClouds();
                        loaded = true;
                        resolve(null);
                        return;
                    }

                    console.log('å°è¯•åŠ è½½é™æ€äº‘å›¾:', url);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.crossOrigin = 'anonymous';

                    textureLoader.load(
                        url,
                        function(texture) {
                            if (!loaded) {
                                loaded = true;
                                console.log('é™æ€äº‘å›¾åŠ è½½æˆåŠŸ');
                                updateCloudTexture(texture);
                                resolve(texture);
                            }
                        },
                        function(progress) {
                            console.log('é™æ€äº‘å›¾åŠ è½½è¿›åº¦:', (progress.loaded / progress.total * 100) + '%');
                        },
                        function(err) {
                            console.log('é™æ€äº‘å›¾åŠ è½½å¤±è´¥:', url);
                            // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªURL
                            setTimeout(tryNextUrl, 1000); // çŸ­æš‚å»¶è¿Ÿåé‡è¯•
                        }
                    );
                }

                // å¼€å§‹å°è¯•åŠ è½½
                tryNextUrl();

                // 30ç§’è¶…æ—¶
                setTimeout(() => {
                    if (!loaded) {
                        console.log('é™æ€äº‘å›¾åŠ è½½è¶…æ—¶ï¼Œä½¿ç”¨ç¨‹åºåŒ–äº‘å›¾');
                        createProceduralClouds();
                        resolve(null);
                    }
                }, 30000);
            });
        }

        // æ›´æ–°äº‘å±‚çº¹ç†
        function updateCloudTexture(texture) {
            if (window.cloudsMesh && window.cloudsMesh.material) {
                // è®¾ç½®çº¹ç†å±æ€§
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.encoding = THREE.sRGBEncoding;

                // æ›´æ–°æè´¨
                window.cloudsMesh.material.map = texture;
                window.cloudsMesh.material.alphaMap = texture;
                window.cloudsMesh.material.blending = THREE.NormalBlending;
                window.cloudsMesh.material.needsUpdate = true;

                // æ·»åŠ äº‘å±‚åŠ¨ç”»æ•ˆæœ
                animateCloudOpacity();

                console.log('äº‘å±‚çº¹ç†å·²æ›´æ–°');
            }
        }

        // äº‘å±‚é€æ˜åº¦åŠ¨ç”»
        function animateCloudOpacity() {
            if (!window.cloudsMesh || !cloudsVisible) return;

            let opacity = 0.2;
            let increasing = true;

            function animate() {
                if (!window.cloudsMesh || !cloudsVisible) return;

                if (increasing) {
                    opacity += 0.005;
                    if (opacity >= 0.5) increasing = false;
                } else {
                    opacity -= 0.005;
                    if (opacity <= 0.3) increasing = true;
                }

                window.cloudsMesh.material.opacity = opacity;
                setTimeout(animate, 100);
            }

            animate();
        }

        // åˆ›å»ºç¨‹åºåŒ–äº‘å›¾ä½œä¸ºæœ€ååå¤‡
        function createProceduralClouds() {
            console.log('åˆ›å»ºç¨‹åºåŒ–äº‘å›¾...');

            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // åˆ›å»ºäº‘å±‚çš„åŸºç¡€å™ªå£°
            for (let x = 0; x < 512; x++) {
                for (let y = 0; y < 256; y++) {
                    // ç®€å•çš„å™ªå£°å‡½æ•°
                    const noise = Math.sin(x * 0.01) * Math.cos(y * 0.01) +
                                Math.sin(x * 0.02 + y * 0.03) * 0.5 +
                                Math.random() * 0.2;

                    const intensity = Math.max(0, Math.min(1, (noise + 1) / 2));
                    const alpha = intensity * 0.6; // äº‘çš„é€æ˜åº¦

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            updateCloudTexture(texture);
        }

        // å¯åŠ¨æ—¶é—´æ˜¾ç¤º
        updateTimeDisplay();

        // ä»localStorageæ¢å¤ä¿å­˜çš„ä½ç½®å’Œè®¾ç½®
        restoreSavedSettings();

        // åˆå§‹åŒ–å¤©æ°”é¢„æŠ¥
        initWeather();

        // ä¿å­˜ç”¨æˆ·è®¾ç½®åˆ°localStorage
        function saveUserSettings() {
            try {
                // ä¿å­˜å½“å‰åŸå¸‚
                localStorage.setItem(STORAGE_KEYS.CITY, currentCity);

                // ä¿å­˜å½“å‰ä½ç½®åæ ‡
                const locationData = {
                    lat: currentLocationLat,
                    lon: currentLocationLon
                };
                localStorage.setItem(STORAGE_KEYS.LOCATION, JSON.stringify(locationData));

                // ä¿å­˜ç›¸æœºä½ç½®å’Œç›®æ ‡
                if (camera && controls) {
                    const cameraData = {
                        position: camera.position.toArray(),
                        target: controls.target.toArray()
                    };
                    localStorage.setItem(STORAGE_KEYS.CAMERA_POSITION, JSON.stringify(cameraData));
                }

                console.log('ç”¨æˆ·è®¾ç½®å·²ä¿å­˜');
            } catch (error) {
                console.warn('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
            }
        }

        // ä»localStorageæ¢å¤ä¿å­˜çš„è®¾ç½®
        function restoreSavedSettings() {
            try {
                // æ¢å¤ä¿å­˜çš„åŸå¸‚
                const savedCity = localStorage.getItem(STORAGE_KEYS.CITY);
                if (savedCity) {
                    currentCity = savedCity;
                    console.log('æ¢å¤ä¿å­˜çš„åŸå¸‚:', savedCity);
                }

                // æ¢å¤ä¿å­˜çš„ä½ç½®åæ ‡
                const savedLocation = localStorage.getItem(STORAGE_KEYS.LOCATION);
                if (savedLocation) {
                    try {
                        const locationData = JSON.parse(savedLocation);
                        if (locationData.lat && locationData.lon) {
                            currentLocationLat = locationData.lat;
                            currentLocationLon = locationData.lon;
                            console.log('æ¢å¤ä¿å­˜çš„ä½ç½®åæ ‡:', currentLocationLat, currentLocationLon);
                        }
                    } catch (error) {
                        console.warn('è§£æä¿å­˜çš„ä½ç½®åæ ‡å¤±è´¥:', error);
                        // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•ä»åŸå¸‚åç§°è·å–åæ ‡
                        if (savedCity) {
                            getCityCoordinates(savedCity).then(coords => {
                                if (coords) {
                                    currentLocationLat = coords.lat;
                                    currentLocationLon = coords.lon;
                                }
                            });
                        }
                    }
                } else if (savedCity) {
                    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„ä½ç½®åæ ‡ï¼Œä½†æœ‰åŸå¸‚åç§°ï¼Œè·å–å…¶åæ ‡
                    getCityCoordinates(savedCity).then(coords => {
                        if (coords) {
                            currentLocationLat = coords.lat;
                            currentLocationLon = coords.lon;
                        }
                    });
                }

                // æ¢å¤ç›¸æœºä½ç½®
                const savedCamera = localStorage.getItem(STORAGE_KEYS.CAMERA_POSITION);
                if (savedCamera && camera && controls) {
                    const cameraData = JSON.parse(savedCamera);
                    if (cameraData.position && cameraData.target) {
                        camera.position.fromArray(cameraData.position);
                        controls.target.fromArray(cameraData.target);
                        controls.update();
                        console.log('æ¢å¤ä¿å­˜çš„ç›¸æœºä½ç½®');
                    }
                }

                // å¦‚æœæœ‰ä¿å­˜çš„åŸå¸‚ï¼Œæ¢å¤å…¶ä½ç½®æ ‡è®°
                if (savedCity && savedCity !== 'åŒ—äº¬') {
                    // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿åœºæ™¯å·²åŠ è½½
                    setTimeout(() => {
                        getCityCoordinates(savedCity).then(coords => {
                            if (coords) {
                                markLocationAt(coords.lat, coords.lon, savedCity);
                            }
                        });
                    }, 1000);
                }

            } catch (error) {
                console.warn('æ¢å¤è®¾ç½®å¤±è´¥:', error);
            }
        }
    </script>
</body>
</html>